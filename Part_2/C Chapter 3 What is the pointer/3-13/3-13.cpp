#include <stdio.h>	// 다음 예제는 주소의 가산을 통해 포인터와 배열의 관계를 보여주는 코드이다.
int main() {
	int array[3] = { 10,20,30 };
	int* ip = NULL;
	int** ipp = NULL;

	ip = array;
	ipp = &ip;

	printf("%d %d %d \n", array[0], array[1], array[2]);
	printf("%d %d %d \n", *(ip + 0), *(ip + 1), *(ip + 2));
	printf("%d %d %d \n", *(*ipp + 0), *(*ipp + 1), *(*ipp + 2));

	return 0;
}

//
//
// 4행에서 1차원 배열 array[3]을 선언하고 동시에 초기화를 수행한다.
// 
// 8행에서는 1차원 포인터 변수 ip에 array(배열의 시작 주소)를 저장한다.
// 
// 9행에서는 2차원 포인터 변수 ipp에 &ip(1차원 포인터 변수의 주소)를 저장한다.
// 
// 11행에서는 1차원 배열의 요소 array[0], array[1], array[2]를 출력한다. 그래서 10, 11, 12가 출력된다.
// 
// 
// 12행에서는 *(ip+0), *(ip+1), *(ip+2)를 출력한다. ip에 array(배열의 시작 주소)를 저장하고 있기 때문에
// *(array+0), *(array+1), *(array+2)와 같은 표현이 된다.
// 
// 13행에서는 *(*ipp+0), *(*ipp+1), *(*ipp+2)를 출력한다. ipp에 &ip를 저장하고 있기 때문에 *(*&ip+0), *(*&ip+1),
// *(*&ip+2)가 된다. *&는 서로 상쇄되므로 결국, *(*&ip+0),*(*&ip+1), *(*&ip+2)가 된다. *&는 서로 상쇄되므로 결국
// *(ip+0),*(ip+1), *(ip+2)와 같은 표현이 된다. 
// 
// 
// 
//			*(array+i)==array[i]==*&array[i]
// 
// 
// 
//  
//
