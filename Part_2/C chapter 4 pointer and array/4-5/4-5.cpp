#include <stdio.h>
int main(void) {
	int array[3] = { 10,20,30 };
	int* p = NULL;
	p = array;			// p=&array[0]; 포인터 변수에 배열의 시작 주소를 저장

	printf("%d %d %d \n", p, *(p + 0), *&p[0]);			// 배열의 0번 요소에 저장된 값
	printf("%d %d \n", *(p + 1), *&p[1]);				// 배열의 1번 요소에 저장된 값
	printf("%d %d \n", *(p + 2), *&p[1]);				// 배열의 2번 요소에 저장된 값


	return 0;
}

//
// 포인터 변수에 배열의 시작 주소를 저장해서 주소의 가감산(예를 들어 p+0,p+1,p+2 ...)과 * 연산자를 통해 값이
// 접근할 수 있었다.
// 
// 
// 
// 6행에서 포인터 변수 p에 배열의 시작 주소 array를 저장된다. 따라서 포인터 변수 p는 지금부터 배열의 주소를 저장하고
// 있어서 배열처럼 사용할 수 있다.
// 
// 
// 9행에서 *p는 p에 저장된 저장된 주소가 가리키는 메모리 공간에 저장된 값을 참조하라는 의미가 된다. *(p+0)은 p에서 0만큼
// 주소가 가리키는 메모리 공간에 저장된 값을 참조하라는 의미가 되고, *(p+0)==p[0]과 같은 표현이다.
// 
// 
// 10행에서 *(p+1)은 p에서 1만큼 증가(p에 저장된 값은 int형이므로 4바이트 증가)된 주소가 가리키는 메모리 공간에 저장된 값을 참조하라는
// 의미가 되고, *&p[1]은 *(p+1)==p[1]과 같은 표현이다.
// 
// 11행에서 *(p+2)는 p에서 2만큼 증가(p에 저장된 값은 int형이므로 8바이트 증가)된 주소가 가리키는 메모리 공간에 저장된 값을 참조하라는
// 의미가 되고, *&p[2]는 *(p+2)==p[2]와 같은 표현이다.
// 
//