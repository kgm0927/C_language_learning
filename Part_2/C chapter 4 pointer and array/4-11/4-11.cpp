#include <stdio.h>				// 이 예제는 포인터 변수 p를 이동시켜 배열의 메모리 공간에 접근하는 방식이다.
int main(void) {
	
	int array[3];
	int* p = NULL;

	p = array;

	*p = 10;
	printf("%d %d %d \n", p[0], p[1], p[2]);
	printf("-------------------------\n");

	p += 1;
	*p = 20;
	printf("%d %d %d \n", p[-1], p[0], p[1]);
	printf("------------------------ \n");


	p += 1;
	*p = 30;
	printf("%d %d %d \n", p[-2], p[-1], p[0]);
	printf("%d %d %d \n", *(p - 2), *(p - 1), *p);
	printf("------------------------ \n");


	printf("%d %d %d \n", array[0], array[1], array[2]);


	return 0;



}

//
// 다음 예제는 포인터 변수p를 이동시켜 배열의 메모리 공간에 접근하는 방식이다.
// 
// 7,8 행에서 포인터 변수 p에 배열 이름 array를 저장한다. *p에 값을 초기화한다. 초기화된 메모리
// 공간은 포인터 변수 p 측면에서는 *p즉 *(p+0)이고, 배열 array 측면에서는 array[0],즉 *array의
// 메모리 공간을 초기화한다. 현재 p=array이다.
// 
// 12행에서 포인터 변수 p에 p+1을 저장한다. 먼저 p+1부터 보겠다. 7행에서 p=array가 수행되었다.
// 따라서 p+1에서 p는 array가 되고, +1를 하게 되면 array+1과 같은 의미가 된다.결론적으로 p=p+1은
// p=array+1과 같다.
// 
// 13행에서 *p에 값을 초기화한다. p에 저장된 주소는 array+1이기 때문에 초기화된 메모리 공간은 포인터
// 변수 p 측면에서는 *p 즉 *(p+0)==p[0]이고, 배열 array 측면에서는 array[1], 즉 *(array+1)의 메모리 공간을
// 초기화한다.
// 
// 17행에서 포인터 변수 p에 먼저 p+1부터 보겠다. 먼저 p+1부터 보겠다. 12행에서 p=array+1 이 수행됬는데,
// 따라서 p+1에서 p는 array+1가 되고, +1를 하게 되면 array+2와 같은 의미가 된다. 결론적으로 p=p+1
// 은 p=array+2와 같다. 
// 
// 18행에서 *p에 값을 초기화한다. p에 저장된 주소는 array+2이기 때문에 초기화된 메모리 공간은
// 포인터 변수 p 측면에서는 *p 즉 *(p+0)==p[0]이고, 배열 array 측면에서는 array[2], 즉 *(array+2)
// 의 메모리 공간을 초기화한다.
// 
// 포인터 변수 p가 어떤 주소를 저장하고 있는가에 따라서 *p 표현 하나로 다양한 주소의 메모리 공간을 참조할
// 수 있다는 사실을 기억해야 한다.
//