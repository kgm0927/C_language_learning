#include <stdio.h>

int func(int* i);

void main() {
	int a = 10;
	int result = 0;

	result = func(&a);
	printf("%d \n", result);
	printf("%d \n", a);

}


int func(int* i) {
	*i += 1;
	return *i;

}

//
// 
//		주소에 의한 호출
// 
// 앞에서 설명한 값에 의한 호출과 다르게 주소에 의한 호출은 주소를 참조해서 함수를 호출한다.
// 이 방식을 사용하면 전달받은 주소를 이용해서 해당 주소에 저장된 값에 접근하여 변경하기도 한다.
//
// 
// 3행에서 출력 형태는 int, 입력 형태는 int* i, 11 형태(출력 형태 있음, 입력 형태 있음)의 함수를 선언한다.
// 
// 
// 
// 10행에서 변수 a의 주소, 즉 &a로 func(int *i) 함수를 호출한다.
// 주소에 의한 호출이다. 15행에서 포인터 변수 i가 생성되고, 포인터
// 변수 i에 &a가 저장된다. i와 &a는 서로 같은 주소이다.
// 
// 
// 17행에서 *연산자를 통해 i에 저장된 주소(&a)를 이용하여 해당 주소(&a)에 저장된
// 값에 접근한다. 즉 *i의 의미는 *&a와 같다. 따라서 *i=*i+1의 의미는 a=a+i와 같다.
// 
// 
// 18행에서 *i(a에 저장된 값, *&a)가 호출된 영역으로 반환된다. 이때 func() 함수를 호출한 영역인
// 10행으로 반환된다.
// 
// 
// 11행과 12행에서 변수 result에 저장된 값 11, 변수 a에 저장된 값 11, 변수 a에 저장된 값 11을 출력한다.
// 
// 
// 
// 주소에 의한 호출의 필요성
// 
// 값에 의한 호출은 함수를 호출할 때 제약이 있다. 함수에 대량의 데이터를 전달해야 하는 경우, 함수의
// 매개변수(지역변수)들이 늘어나서 이들이 하나하나 스택 영역에 쌓이는데 많은 시간과 메모리 공간을 필요로 한다.
// 
// 
// 따라서 배열이나 구조체와 같은 데이터를 함수에 전달할 때는 '주소에 의한 호출'이 실행 시간과 메모리 공간 측면에서
// 좋은 성능을 제공한다. 
//  
//