#include <stdio.h>
// 이제 구조체에서 포인터를 사용하는 두 번째 경우인 구조체 변수로 포인터 사용하기에 대하여 살펴본다.
struct student
{
	char no[10];
	char name[20];
	double total;
};

int main(void) {

	struct student stu = { "20101323","Park",160 };
	struct student* p = NULL;

	p = &stu;
	printf("%s %s %lf \n", stu.no, stu.name, stu.total);
	printf("%s %s %lf \n", (*p).no, (*p).name, (*p).total);
	printf("%s %s %lf \n", p->no, p->name, p->total);

	return 0;
}

//
// 
// 구조체 변수로 포인터를 사용한다는 의미는 구조체 변수에 간접 접근할 수 있다는 의미이다.
// 간접 접근을 위해서는 대상이 되는 구조체 변수의 주소를 알면 간단하다.
// 
// 
// 13행에서 구조체 변수로 1차원 포인터 p를 선언하고, 15행에서 p에 구조체 구조체 변수 stu의 시작 주소
// &stu를 저장한다. 이제부터는 p를 통해 다른 구조체 변수 stu에 간접 접근할 수 있다.
// 
// 
// 17행의 (*p).no 하나만 분석해 본다. 의문 사항은 왜 (*p).no에서 괄호를 사용하였는지 이다.
// 이유는 .연산자가 * 연산자보다 우선순위가 높아서 (*p)를 먼저 처리하기 위해서이다. 그러면
// (*p)의 의미는 무엇일까? 
// 
// (*p)는 p가 가리키는 구조체 변수를 의미한다. 즉, 1차원 구조체 포인터 변수 p에 구조체 변수 stu의 시작
// 주소인 &stu가 저장되어 있으므로 (*p).no==(*&stu).no가 성립한다. *&는 서로 상쇄된다.
// 
// 
// (*p).no==(*&stu).no==stu.no			// p가 기준이 됨
// 
// 
// 만약 괄호를 사용하지 않았다면, .연산자의 우선순위가 높아서 *p.no는 *(p.no)와 같은 표현이 된다.
// 
// 
// *p.no==*(p.no)==*(&stu.no)				// p.no가 기준이 됨
// 
// 18행에서 -> 연산자는 포인터 변수에만 사용한다. 즉, -> 연산자는 포인터 변수만으로 구조체의 멤버
// 변수에 접근할 때 사용한다.
// 
// 
//		(*p).no==p->no
// 
// 실제로는 . 보다 -> 연산자를 더 많이 사용한다. -> 연산자는 구조체 포인터 변수에서만 사용이 가능하다.
// 
// 
// 
//
